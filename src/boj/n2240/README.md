## 백준  - [백설공주와 난쟁이](https://www.acmicpc.net/problem/2912)


메모이제이션 배열을 3차원으로 사용.

### 풀이법

1. 자두나무의 위치가 2개, t번의 자두의 떨어짐, w만큼 자두가 움직일 수 있다.
- 3차원 메모이제이션 배열 사용 memo[3][t+1][w + 2]
- 크기는 버퍼를 두어 각 차원당 1개씩 크다(움직임은 0번 부터 존재하므로 w + 2 의 크기)
- memo[자두의 위치][떨어지는 시간][최대 움직임의 횟수] --> 움직임의 횟수는 1을 빼야 실제 움직임의 횟수이다.
- 배열의 원소는 그 상황에서의 최대로 받을 수 있는 자두의 갯수이다.
 
~~~JAVA
int[][][] memo = new int[3][t + 1][w + 2];

int[] plum = new int[t + 1];

for (int i = 1; i <= t; i++) {
    plum[i] = Integer.parseInt(br.readLine());
}
~~~

2. 자두가 떨어지는 시간에 대해서, 0번부터 w번 움직였을때까지로 배열을 채워나간다.
~~~JAVA
// 자두가 떨어지는것에 대한 루프.
for (int i = 1; i <= t; i++) {

    // 몇번 움직였나에 대한 루프.
    for (int j = 1; j <= w + 1; j++) {

        // 자두가 1의 자리에 떨어질 경우.
        if (plum[i] == 1) {

            // 자두가 1의 자리에 떨어졌을경우. 이전에 1의 자리에 있었을때와 2의자리에서 움직여서 먹었을때의 최대값으로 갱신한다.
            memo[1][i][j] = Math.max(memo[1][i - 1][j], memo[2][i - 1][j - 1]) + 1;

            // 2의 자리의 값을 이전에서 자두가 움직였을때와 그대로 있었을때 중의 최대값으로 갱신해 준다.
            memo[2][i][j] = Math.max(memo[1][i - 1][j - 1], memo[2][i - 1][j]);

        } else { // 자두가 2의 자리에 떨어질 경우.
            if (i == 1 && j == 1) {
                // 첫 시작이 2일 경우. 
                // j 가 1이라는 의미는 움직임이 0임을 뜻한다. -> 무조건 움직여서 받아야 하기 때문에 못먹는 상황.
                continue;
            }

            // 자두가 2의 자리에 떨어졌을경우. 이전에 2의 자리에 있었을때와 1의자리에서 움직여서 먹었을때의 최대값으로 갱신한다.
            memo[2][i][j] = Math.max(memo[2][i - 1][j], memo[1][i - 1][j - 1]) + 1;

            // 1의 자리의 값을 이전에서 자두가 움직였을때와 그대로 있었을때 중의 최대값으로 갱신해 준다.
            memo[1][i][j] = Math.max(memo[2][i - 1][j - 1], memo[1][i - 1][j]);
        }
    }
}
int answer = Integer.MIN_VALUE;

// 끝에서 몇번 움직였는가에 대해 최대값을 뽑는다.
for (int i = 1; i <= w + 1; i++) {
    answer = Math.max(answer, Math.max(memo[1][t][i], memo[2][t][i]));
}
~~~
